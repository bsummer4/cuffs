package require snit 2 

proc random i { expr int ( rand ( ) * $i ) }
proc t args { puts [list "trace:" {*}$args] }
proc list_with list {
    for {set i 0} {$i < [llength $list]} {incr i} {
        uplevel "set $i [lindex $list $i]" }}

proc appendl args {
    set result [list]
    foreach arg $args {
        foreach elt $arg {
            lappend result $elt }}
    return $result }

proc every {ms command} {
    uplevel #0 $command
    after $ms [list every $ms $command] }


# Slave Interpeter

interp create -safe safe
foreach proc {circle_ent rect_ent} { safe alias $proc $proc }

proc safeeval str { safe eval [list eval $str] }


# Ents

set ents [list]
proc entapply {} {
	white
	set ::ents [lsearch -all -inline -not -exact $::ents HACK]
	foreach ent $::ents { $ent apply }
	flip }

snit::type ent {
	variable cmd
	constructor val { set cmd $val; lappend ::ents $self }
	destructor { lset ::ents [lsearch -exact $::ents $self] HACK }
	method apply {} { eval $cmd }
	method GetSet {i n argz} {
		switch [llength $argz] {
			0 { lindex $cmd $i }
			1 { lset cmd $i [lindex $argz 0] }
			default { error "Too many arguements to '$self $n'" }}}}

snit::type rect_ent {
	variable int
	constructor args {
		set int [::ent $self.ent [list rect {*}$args]]
		safe alias $self $self }
	destructor { $int destroy }
	method point1 args { $int GetSet 1 point1 $args }
	method point2 args { $int GetSet 2 point2 $args }
	method color args { $int GetSet 3 color $args }}

snit::type circle_ent {
	variable int
	constructor args {
		set int [ent $self.ent [list circle {*}$args]]
		safe alias $self $self }
	destructor { $int destroy }
	method radius args { $int GetSet 1 radius $args }
	method pos args { $int GetSet 2 pos $args }
	method color args { $int GetSet 3 color $args }}


# Input handling

set buf {}
proc interpret line {
	append ::buf $line "\n"
	if {[info complete $::buf]} {
		if {[catch [list safeeval $::buf] msg]} {
			puts stderr "Error: $msg" }
		set ::buf {}}}

proc go {} {
    if {[eof stdin]} exit
    set line [gets stdin]
    interpret $line }

proc oninput dict { puts [list input $dict] }

fileevent stdin readable go
